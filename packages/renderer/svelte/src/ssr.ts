/**
 * Svelte SSR renderer for Astro components
 * Implements server-side rendering with Svelte
 */

import type { ComponentNode } from '@minimal-astro/internal-helpers';
import { createContextualLogger } from '@minimal-astro/internal-helpers';

// ============================================================================
// TYPES
// ============================================================================

export interface SvelteSSROptions {
  /**
   * Component registry for resolving imports
   */
  components?: Map<string, unknown>;

  /**
   * Props to pass to components
   */
  props?: Record<string, unknown>;

  /**
   * Whether to include hydration data
   */
  generateHydrationData?: boolean;

  /**
   * Development mode (includes extra debugging)
   */
  dev?: boolean;
}

export interface SvelteSSRResult {
  /**
   * Rendered HTML string
   */
  html: string;

  /**
   * CSS generated by the component
   */
  css?: string;

  /**
   * Hydration data for client-side
   */
  hydrationData?: SvelteHydrationData;

  /**
   * Error that occurred during rendering
   */
  error?: Error;
}

export interface SvelteHydrationData {
  /**
   * Component ID
   */
  id: string;

  /**
   * Component name/path
   */
  component: string;

  /**
   * Props passed to the component
   */
  props: Record<string, unknown>;

  /**
   * Client directive configuration
   */
  directive?: {
    type: 'load' | 'idle' | 'visible' | 'media' | 'only';
    value?: string;
  };
}

// ============================================================================
// MAIN RENDERER
// ============================================================================

/**
 * Renders a Svelte component to HTML string with optional hydration data
 */
export function renderSvelteComponent(
  componentName: string,
  SvelteComponent: unknown,
  props: Record<string, unknown> = {},
  options: SvelteSSROptions = {}
): SvelteSSRResult {
  const logger = createContextualLogger({ module: 'svelte-ssr' });

  try {
    // Generate hydration data if requested
    let hydrationData: SvelteHydrationData | undefined;
    if (options.generateHydrationData) {
      hydrationData = {
        id: generateComponentId(componentName),
        component: componentName,
        props,
        directive: extractClientDirective(props),
      };
    }

    let html: string;
    let css: string | undefined;

    // Check if this is a real Svelte component with render method
    if (SvelteComponent && typeof (SvelteComponent as any).render === 'function') {
      // Real Svelte SSR
      const result = (SvelteComponent as any).render(props);
      html = result.html;
      css = result.css?.code;
    } else {
      // Fallback for when Svelte isn't available or component isn't compiled
      const componentTag = componentName.toLowerCase().replace(/([A-Z])/g, '-$1');
      const propsString = Object.entries(props)
        .map(([key, value]) => {
          if (typeof value === 'string') {
            return `${key}="${escapeHtml(value)}"`;
          }
          return `${key}="${escapeHtml(JSON.stringify(value))}"`;
        })
        .join(' ');

      html = `<${componentTag}${propsString ? ` ${propsString}` : ''}></${componentTag}>`;
    }

    // Wrap with hydration data if needed
    if (hydrationData) {
      html = `<astro-island component-export="${componentName}" component-props="${escapeHtml(JSON.stringify(props))}" client-directive="${hydrationData.directive?.type || ''}" data-astro-cid="${hydrationData.id}">
				${html}
			</astro-island>`;
    }

    logger.debug(`Successfully rendered Svelte component ${componentName}`, {
      propsCount: Object.keys(props).length,
      hasHydration: !!hydrationData,
      hasCss: !!css,
    });

    return {
      html,
      css,
      hydrationData,
    };
  } catch (error) {
    const renderError = error instanceof Error ? error : new Error(String(error));

    logger.error(`Failed to render Svelte component ${componentName}`, renderError, { props });

    return {
      html: `<!-- Error rendering ${componentName}: ${renderError.message} -->`,
      error: renderError,
    };
  }
}

/**
 * Renders a Svelte component from AST node
 */
export function renderSvelteComponentFromNode(
  node: ComponentNode,
  options: SvelteSSROptions = {}
): SvelteSSRResult {
  const { components = new Map() } = options;
  const componentName = node.tag;

  // Look up the component
  const Component = components.get(componentName);
  if (!Component) {
    const error = new Error(`Svelte component "${componentName}" not found in registry`);
    return {
      html: `<!-- Svelte component ${componentName} not found -->`,
      error,
    };
  }

  // Extract props from node attributes
  const props = extractPropsFromNode(node);

  return renderSvelteComponent(componentName, Component, props, options);
}

// ============================================================================
// UTILITIES
// ============================================================================

/**
 * Extracts props from AST component node
 */
function extractPropsFromNode(node: ComponentNode): Record<string, unknown> {
  const props: Record<string, unknown> = {};

  for (const attr of node.attrs || []) {
    if (attr.name.startsWith('client:')) {
      continue;
    }

    if (attr.value) {
      try {
        if (
          typeof attr.value === 'string' &&
          (attr.value.startsWith('{') || attr.value.startsWith('['))
        ) {
          props[attr.name] = JSON.parse(attr.value);
        } else {
          props[attr.name] = attr.value;
        }
      } catch {
        props[attr.name] = attr.value;
      }
    } else {
      props[attr.name] = true;
    }
  }

  return props;
}

/**
 * Extracts client directive from props
 */
function extractClientDirective(props: Record<string, unknown>): SvelteHydrationData['directive'] {
  for (const [key, value] of Object.entries(props)) {
    if (key.startsWith('client:')) {
      const directiveType = key.slice(7) as 'load' | 'idle' | 'visible' | 'media' | 'only';
      return {
        type: directiveType,
        value: typeof value === 'string' ? value : undefined,
      };
    }
  }
  return undefined;
}

/**
 * Escapes HTML entities
 */
function escapeHtml(text: string): string {
  const map: Record<string, string> = {
    '&': '&amp;',
    '<': '&lt;',
    '>': '&gt;',
    '"': '&quot;',
    "'": '&#039;',
  };
  return text.replace(/[&<>"']/g, (m) => map[m]);
}

/**
 * Generates a unique component ID for hydration
 */
function generateComponentId(componentName: string): string {
  const timestamp = Date.now().toString(36);
  const random = Math.random().toString(36).substr(2, 5);
  return `svelte-${componentName}-${timestamp}-${random}`;
}

/**
 * Creates a Svelte SSR renderer with configured options
 */
export function createSvelteSSRRenderer(options: SvelteSSROptions = {}) {
  return {
    /**
     * Render a component by name
     */
    render(componentName: string, props: Record<string, unknown> = {}): SvelteSSRResult {
      const Component = options.components?.get(componentName);
      if (!Component) {
        return {
          html: `<!-- Svelte component ${componentName} not found -->`,
          error: new Error(`Component "${componentName}" not found`),
        };
      }

      return renderSvelteComponent(componentName, Component, props, options);
    },

    /**
     * Render from AST node
     */
    renderNode(node: ComponentNode): SvelteSSRResult {
      return renderSvelteComponentFromNode(node, options);
    },

    /**
     * Register a component
     */
    register(name: string, component: unknown): void {
      if (!options.components) {
        options.components = new Map();
      }
      options.components.set(name, component);
    },

    /**
     * Get all registered components
     */
    getComponents(): Map<string, unknown> {
      return options.components || new Map();
    },
  };
}
